{
	"glsl" : "#version 410 core\nlayout (location = 0) out vec3 gPos;\nlayout (location = 1) out vec3 gNorm;\nlayout (location = 2) out vec4 gAlbedo;\nlayout (location = 3) out float gSpec;\nlayout (location = 4) out float gShadow;\nlayout (location = 5) out vec3 gMetRoughAO;\n\nin vec3 Normal;\nin vec3 Tan;\nin vec3 Bitan;\n\nin vec3 FragPos;\nin vec2 UVcoord;\n\nin vec4 FragPosLightSpace[10];\n\nuniform sampler2D ShadowMap[10];\nuniform int NbrDirLights;\n\nfloat ProcessShadows() {\n\tfloat finalShadow = 0.0;\n\n\tfor(int i = 0; i < NbrDirLights; i++) {\n\t\tvec3 projCoords = FragPosLightSpace[i].xyz / FragPosLightSpace[i].w;\n\t\tprojCoords = projCoords * 0.5 + 0.5;\n\n\t\tif(projCoords.z > 1.0) {\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tfloat closestDepth = texture(ShadowMap[i], projCoords.xy).r;\n\t\tfloat currentDepth = projCoords.z;\n\n\t\tfloat bias = 0.0015;\n\n\t\tfloat shadow = 0.0;\n\n\t\tvec2 texelSize = 1.0 / textureSize(ShadowMap[i], 0);\n\t\tfor(int x = -1; x <= 1; x++) {\n\t\t\tfor(int y = -1; y <= 1; y++) {\n\t\t\t\tfloat pcfDepth = texture(ShadowMap[i], projCoords.xy + vec2(x, y) * texelSize).r;\n\t\t\t\tshadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;\n\t\t\t}\n\t\t}\n\n\t\tfinalShadow += shadow / 9;\n\t}\n\n\treturn finalShadow;\n}\nvoid main() {\ngAlbedo = vec4(vec3(1.000000,1.000000,1.000000), 0.0);\ngPos = FragPos;\ngNorm = Normal;\ngSpec = 0.0;\ngMetRoughAO = vec3(0.0,0.0,0.0);\ngShadow = ((1.000000)-ProcessShadows());\n}"
}