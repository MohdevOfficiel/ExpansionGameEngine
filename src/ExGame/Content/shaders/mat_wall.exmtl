{
    "textures" : [
		{
			"path":"Content/textures/wall_diff.jpg",
			"param":"diff"
		},

		{
			"path":"Content/textures/wall_norm.jpg",
			"param":"normMap"
		},

		{
			"path":"Content/textures/wall_rough.jpg",
			"param":"roughMap"
		}
	],

    "glsl":
"
#version 410 core
layout (location = 0) out vec3 gPos;
layout (location = 1) out vec3 gNorm;
layout (location = 2) out vec4 gAlbedo;
layout (location = 3) out float gSpec;
layout (location = 4) out float gShadow;
layout (location = 5) out vec3 gMetRoughAO;

in vec3 Normal;
in vec3 Tan;
in vec3 Bitan;

in vec3 FragPos;
in vec2 UVcoord;

in vec4 FragPosLightSpace[10];

uniform sampler2D ShadowMap[10];
uniform int NbrDirLights;

float ProcessShadows(sampler2D SMap, vec4 FPLS) {
	vec3 projCoords = FPLS.xyz / FPLS.w;
	projCoords = projCoords * 0.5 + 0.5;

	if(projCoords.z > 1.0) {
		return 0.0;
	}

	float closestDepth = texture(SMap, projCoords.xy).r;
	float currentDepth = projCoords.z;

	float bias = 0.0025;

	float shadow = 0.0;

	vec2 texelSize = 1.0 / textureSize(SMap, 0);
	for(int x = -1; x <= 1; x++) {
		for(int y = -1; y <= 1; y++) {
			float pcfDepth = texture(SMap, projCoords.xy + vec2(x, y) * texelSize).r;
			shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
		}
	}

	return shadow / 9;
	
}

vec3 GetNormFromMap(sampler2D NMap, vec3 n, vec3 FPos, vec2 UV) {
    vec3 tanNorm = texture(NMap, UV).xyz * 2.0 - 1.0;
    
    vec3 Q1 = dFdx(FPos);
    vec3 Q2 = dFdy(FPos);
    vec2 st1 = dFdx(UV);
    vec2 st2 = dFdy(UV);
    
    vec3 Nm = normalize(n);
    vec3 T = normalize(Q1 * st2.t - Q2 * st1.t);
    vec3 B = -normalize(cross(Nm, T));
    mat3 TBN = mat3(T, B, Nm);

    return normalize(TBN * tanNorm);
}

uniform sampler2D diff;
uniform sampler2D normMap;
uniform sampler2D roughMap;

void main() {
	vec2 UVs = UVcoord * 4;

    gPos = FragPos;
    gNorm = GetNormFromMap(normMap, Normal, FragPos, UVs);

	gAlbedo.rgb = texture(diff, UVs).rgb;
    gAlbedo.a = 0.8;
    gSpec = 16.0;

	gMetRoughAO = vec3(0.4, texture(roughMap, UVs).r, 1.0);

    float shadow = 0.0;
    for(int i = 0; i < NbrDirLights; i++) {
        shadow += ProcessShadows(ShadowMap[i], FragPosLightSpace[i]);
    }

    gShadow = 1.0 - clamp(shadow, 0.0, 1.0);
}
"
}